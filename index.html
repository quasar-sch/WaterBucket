<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>물통 미션: 정확한 물의 양 만들기</title>
<style>
  :root{
    --bg:#0b1220;
    --ink:#e7eefc;
    --muted:#b8c7f3;
    --line:rgba(255,255,255,.12);
    --accent:#6ee7ff;
    --good:#22c55e;
    --warn:#fbbf24;
    --bad:#fb7185;

    --cup-stroke: rgba(255,255,255,.22);
    --tick: rgba(255,255,255,.28);
    --tickText: rgba(231,238,252,.78);
    --waterTop: rgba(110,231,255,.85);
    --waterBottom: rgba(110,231,255,.28);
    --waterEdge: rgba(255,255,255,.22);
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif;
    background: radial-gradient(1200px 600px at 20% 10%, rgba(110,231,255,.10), transparent 55%),
                radial-gradient(900px 500px at 80% 15%, rgba(34,197,94,.08), transparent 55%),
                radial-gradient(1000px 600px at 50% 95%, rgba(251,113,133,.10), transparent 60%),
                var(--bg);
    color:var(--ink);
    min-height:100vh;
  }
  .wrap{max-width:1040px;margin:0 auto;padding:22px}
  .card{
    background: linear-gradient(180deg, rgba(16,26,46,.92), rgba(12,20,40,.92));
    border:1px solid var(--line);
    border-radius:18px;
    box-shadow: 0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }

  /* 상단 UX 개선 */
  .topbar{
    padding:16px 18px;
    border-bottom:1px solid var(--line);
    display:flex;
    align-items:flex-end;
    justify-content:space-between;
    gap:14px;
  }
  .title{
    display:flex;
    flex-direction:column;
    gap:6px;
    min-width:260px;
  }
  .title .modeLine{
    display:flex;align-items:center;gap:10px;flex-wrap:wrap;
  }
  .title h1{
    margin:0;
    font-size:22px;
    letter-spacing:.2px;
    line-height:1.1;
  }
  .sub{
    margin:0;
    color:var(--muted);
    font-size:12px;
    line-height:1.35;
  }
  .badge{
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding:6px 10px;
    border-radius:999px;
    border:1px solid var(--line);
    background: rgba(255,255,255,.04);
    font-size:12px;
    color:var(--muted);
    white-space:nowrap;
  }
  .badge strong{color:var(--ink)}
  .badge.accent{
    border-color: rgba(110,231,255,.45);
    background: rgba(110,231,255,.10);
  }

  .kpiRow{
    display:flex;
    align-items:flex-end;
    gap:10px;
    flex-wrap:wrap;
    justify-content:flex-end;
  }
  .kpi{
    border:1px solid var(--line);
    background: rgba(255,255,255,.03);
    border-radius:14px;
    padding:10px 12px;
    min-width:112px;
  }
  .kpi .label{font-size:11px;color:var(--muted)}
  .kpi .val{margin-top:2px;font-size:16px;font-weight:900}
  .kpi.goal{
    border-color: rgba(110,231,255,.55);
    background: rgba(110,231,255,.12);
  }
  .kpi.goal .val{font-size:18px}
  .kpi.small{min-width:100px}

  .grid{
    display:grid;
    grid-template-columns: 1.2fr .8fr;
    gap:14px;
    padding:14px;
  }
  @media (max-width: 900px){
    .grid{grid-template-columns:1fr}
    .topbar{align-items:flex-start}
    .kpiRow{justify-content:flex-start}
  }

  .panel{
    background: rgba(255,255,255,.03);
    border:1px solid var(--line);
    border-radius:16px;
    padding:14px;
  }
  .panel h2{
    margin:0 0 10px 0;
    font-size:14px;color:var(--muted);
    font-weight:800;
    letter-spacing:.2px;
  }
  .btnrow{display:flex;flex-wrap:wrap;gap:10px}

  button{
    appearance:none;border:1px solid var(--line);
    background: rgba(255,255,255,.04);
    color:var(--ink);
    padding:10px 12px;border-radius:12px;
    cursor:pointer;
    font-weight:800;
    transition:.15s transform ease, .15s background ease, .15s border-color ease, .15s opacity ease;
  }
  button:hover{transform: translateY(-1px); background: rgba(255,255,255,.06)}
  button:active{transform: translateY(0px)}
  button.primary{
    border-color: rgba(110,231,255,.35);
    background: rgba(110,231,255,.10);
  }
  button.good{
    border-color: rgba(34,197,94,.35);
    background: rgba(34,197,94,.10);
  }
  button.warn{
    border-color: rgba(251,191,36,.38);
    background: rgba(251,191,36,.10);
  }
  button.bad{
    border-color: rgba(251,113,133,.38);
    background: rgba(251,113,133,.10);
  }
  button.ghost{background: transparent;}
  button:disabled{opacity:.45; cursor:not-allowed;}

  .statusMini{
    margin-top:8px;
    display:flex;gap:10px;flex-wrap:wrap;
    color:var(--muted);
    font-size:12px;
  }
  .statusMini .dot{
    border:1px solid var(--line);
    background: rgba(255,255,255,.03);
    padding:6px 10px;
    border-radius:999px;
  }

  /* Jugs layout */
  .jugs{
    display:flex; gap:12px; justify-content:center; align-items:flex-end;
    padding:10px 6px 6px 6px;
    min-height:340px;
  }
  .jug{
    border:1px solid var(--line);
    background: rgba(255,255,255,.03);
    border-radius:16px;
    padding:10px;
    position:relative;
    user-select:none;
    cursor:pointer;
    transition: .15s transform ease, .15s border-color ease, .15s background ease;
    display:flex;
    flex-direction:column;
    justify-content:flex-end;
  }
  .jug:hover{transform: translateY(-2px); background: rgba(255,255,255,.05)}
  .jug.selected{
    border-color: rgba(110,231,255,.55);
    box-shadow: 0 0 0 3px rgba(110,231,255,.15);
  }
  .jug .cap{
    display:flex; align-items:center; justify-content:space-between;
    font-size:12px; color:var(--muted); margin-bottom:8px;
  }
  .jug .cap strong{color:var(--ink); font-size:12px}

  .jugSvgWrap{
    width:100%;
    display:flex;
    align-items:flex-end;
    justify-content:center;
    border-radius:12px;
    background: rgba(0,0,0,.10);
    border:1px solid rgba(255,255,255,.08);
    overflow:hidden;
    height:230px;
  }
  .jugSvgWrap svg{display:block; width:100%; height:100%}

  .waterGroup{
    transition: transform .38s ease;
    will-change: transform;
  }
  @keyframes waveDrift {
    0%   { transform: translateX(0px); }
    50%  { transform: translateX(2px); }
    100% { transform: translateX(0px); }
  }
  .waveWiggle{
    animation: waveDrift 4.2s ease-in-out infinite;
    transform-origin: center;
  }

  .amt{
    margin-top:8px;
    display:flex; justify-content:space-between; align-items:center;
    font-size:12px; color:var(--muted);
  }
  .amt strong{color:var(--ink)}

  .banner{
    margin-top:10px;
    padding:10px 12px;
    border-radius:12px;
    border:1px solid var(--line);
    background: rgba(255,255,255,.04);
    color:var(--muted);
    font-size:13px; line-height:1.45;
  }
  .banner.warn{border-color: rgba(251,191,36,.35); background: rgba(251,191,36,.08)}
  .banner.bad{border-color: rgba(251,113,133,.35); background: rgba(251,113,133,.08)}
  .row{
    display:flex; align-items:center; justify-content:space-between;
    gap:10px; flex-wrap:wrap;
  }
  .hintbox{
    margin-top:10px;
    border:1px dashed rgba(110,231,255,.28);
    background: rgba(110,231,255,.06);
    padding:10px 12px;border-radius:12px;
    color:var(--muted);
    font-size:13px; line-height:1.45;
    min-height:46px;
  }
  .tiny{font-size:12px;color:var(--muted);line-height:1.45}
  .divider{height:1px;background:var(--line);margin:14px 0}

  /* Modal */
  .modalOverlay{
    position:fixed; inset:0;
    background: rgba(0,0,0,.55);
    display:none;
    align-items:center; justify-content:center;
    padding:18px;
    z-index:50;
  }
  .modal{
    width:min(920px, 100%);
    background: linear-gradient(180deg, rgba(16,26,46,.96), rgba(12,20,40,.96));
    border:1px solid var(--line);
    border-radius:18px;
    box-shadow: 0 22px 60px rgba(0,0,0,.55);
    overflow:hidden;
  }
  .modalHeader{
    padding:14px 16px;
    border-bottom:1px solid var(--line);
    display:flex;align-items:center;justify-content:space-between;
    gap:12px;
  }
  .modalHeader h3{margin:0;font-size:14px}
  .modalBody{padding:14px 16px}
  .modalBody p{margin:0 0 10px 0; color:var(--muted); line-height:1.55; font-size:13px}
  table{
    width:100%;
    border-collapse:collapse;
    overflow:hidden;
    border-radius:14px;
    border:1px solid var(--line);
  }
  th, td{
    padding:10px 10px;
    border-bottom:1px solid var(--line);
    font-size:13px;
    text-align:left;
  }
  th{color:var(--muted); background: rgba(255,255,255,.03)}
  tr:last-child td{border-bottom:none}
  .kpiGrid{
    display:grid;
    grid-template-columns: repeat(3, 1fr);
    gap:10px;
    margin-bottom:12px;
  }
  @media (max-width: 720px){
    .kpiGrid{grid-template-columns:1fr}
  }
  .kpiBox{
    border:1px solid var(--line);
    background: rgba(255,255,255,.03);
    border-radius:14px;
    padding:10px 12px;
  }
  .kpiBox .label{font-size:12px;color:var(--muted)}
  .kpiBox .val{font-size:22px;font-weight:950;margin-top:4px}
  .kpiBox.big{
    border-color: rgba(110,231,255,.55);
    background: rgba(110,231,255,.10);
  }
  .footerRow{
    display:flex;gap:10px;justify-content:flex-end;flex-wrap:wrap;
    padding:12px 16px;
    border-top:1px solid var(--line);
  }

  .start{padding:18px;}
  .modeCard{
    border:1px solid var(--line);
    background: rgba(255,255,255,.03);
    border-radius:16px;
    padding:14px;
  }
  .modeCard h3{margin:0 0 6px 0;font-size:15px}
  .modeCard p{margin:0;color:var(--muted);font-size:13px;line-height:1.55}
  .modeCard .btnrow{margin-top:12px}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">

    <!-- Start Screen -->
    <div id="startScreen">
      <div class="topbar">
        <div class="title">
          <div class="modeLine">
            <h1 style="margin:0">물통 미션</h1>
            <span class="badge"><strong>v1.4</strong> (UX+난이도정렬+하드패널티)</span>
          </div>
          <p class="sub">물을 옮겨 목표한 양을 만들어 보세요.</p>
        </div>
        <div class="kpiRow">
          <div class="badge accent"><strong>Normal</strong> 20스테이지</div>
          <div class="badge"><strong>Hard</strong> 10스테이지</div>
        </div>
      </div>

      <div class="start">
        <div class="grid" style="padding:0">
          <div class="modeCard">
            <h3>Normal 모드</h3>
            <p>
              <strong>정확한 물의 양을 만드는 연습</strong>입니다.<br/>
              힌트가 있으며, <strong>이동을 줄일수록 높은 점수(100점 만점)</strong>를 얻습니다.
            </p>
            <div class="btnrow">
              <button class="primary" id="btnStartNormal">Normal 시작하기</button>
            </div>
            <div class="divider"></div>
            <div class="tiny">
              • 모든 문제는 해결할 수 있습니다.<br/>
              • 난이도 순서로 자동 정렬됩니다.
            </div>
          </div>

          <div class="modeCard">
            <h3>Hard 모드</h3>
            <p>
              <strong>해결할 수 없는 문제</strong>도 포함되어 있습니다.<br/>
              “불가능”을 눌렀는데 틀리면 <strong>1스테이지로 돌아가는 패널티</strong>가 있습니다.
            </p>
            <div class="btnrow" style="margin-top:12px">
              <button class="bad" id="btnStartHard">Hard 도전하기</button>
            </div>
            <div class="divider"></div>
            <div class="tiny">
              • 힌트 없음 / 점수 표시 없음(판단 중심)<br/>
              • 난이도 순서로 자동 정렬됩니다.
            </div>
          </div>
        </div>

        <div class="divider"></div>
        <div class="tiny">
          이 게임은 <strong>정답뿐만 아니라 시도와 판단</strong>을 중요하게 봅니다.
        </div>
      </div>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen" style="display:none">
      <div class="topbar">
        <div class="title">
          <div class="modeLine">
            <h1 id="modeTitle" style="margin:0">Normal</h1>
            <span class="badge accent" id="tierBadge">초급</span>
            <span class="badge" id="progressBadge">1 / 20</span>
          </div>
          <p class="sub" id="stageDesc">설명</p>
        </div>

        <div class="kpiRow">
          <div class="kpi goal">
            <div class="label">목표</div>
            <div class="val" id="goalText">4L</div>
          </div>
          <div class="kpi small">
            <div class="label">스테이지</div>
            <div class="val" id="stageNo">1</div>
          </div>
          <div class="kpi small">
            <div class="label">이동</div>
            <div class="val" id="movesText">0</div>
          </div>
          <div class="kpi small">
            <div class="label">시간</div>
            <div class="val" id="timeText">00:00</div>
          </div>
        </div>
      </div>

      <div class="grid">
        <!-- LEFT PANEL -->
        <div class="panel" id="jugPanel">
          <h2>물통</h2>
          <div class="banner" id="instructionBanner">
            통을 누르면 선택됩니다. 선택된 통이 있을 때 다른 통을 누르면 <strong>물 옮기기</strong>를 시도합니다.<br/>
            빈 공간을 누르면 선택이 취소됩니다.
          </div>

          <div class="jugs" id="jugs"></div>

          <div class="row">
            <div class="tiny" id="selectInfo">선택: 없음</div>
            <div class="btnrow">
              <button id="btnReset" class="ghost">스테이지 리셋</button>
              <button id="btnBackToMenu" class="ghost">메뉴</button>
            </div>
          </div>

          <div class="banner warn" id="loopBanner" style="display:none;margin-top:10px">
            같은 물 상태가 반복되는 것 같습니다. 다른 방법을 시도해 보세요.
          </div>
        </div>

        <div class="panel">
          <h2>조작</h2>
          <div class="btnrow">
            <button id="btnFill" class="primary">채우기</button>
            <button id="btnEmpty">비우기</button>
            <button id="btnDeclareImpossible" class="bad" style="display:none">불가능</button>
          </div>

          <div class="statusMini">
            <div class="dot" id="modeStateText">현재: 선택</div>
          </div>

          <div id="normalHintArea" style="margin-top:12px; display:none">
            <div class="row">
              <h2 style="margin:0;color:var(--muted);font-size:14px">힌트</h2>
              <button id="btnHint" class="warn">힌트 보기</button>
            </div>
            <div class="hintbox" id="hintBox">힌트가 여기에 표시됩니다.</div>
          </div>

          <div id="hardNoteArea" style="margin-top:12px; display:none">
            <div class="banner">
              Hard 모드에서는 “불가능” 버튼을 누르면 바로 판정합니다.<br/>
              틀리면 1스테이지로 돌아갑니다.
            </div>
          </div>

          <div class="divider"></div>
          <div class="tiny">
            • 이동은 <strong>채우기 / 비우기 / 옮기기</strong> 모두 1회로 계산됩니다.<br/>
            • 통 크기는 용량에 따라 조금씩 다릅니다.
          </div>
        </div>
      </div>
    </div>

  </div>
</div>

<!-- Modal -->
<div class="modalOverlay" id="modalOverlay">
  <div class="modal">
    <div class="modalHeader">
      <h3 id="modalTitle">결과</h3>
      <button class="ghost" id="btnCloseModal">닫기</button>
    </div>
    <div class="modalBody" id="modalBody"></div>
    <div class="footerRow" id="modalFooter"></div>
  </div>
</div>

<script>
(() => {
  const $ = (sel) => document.querySelector(sel);
  const pad2 = (n) => String(n).padStart(2,'0');
  const msToMMSS = (ms) => {
    const s = Math.max(0, Math.floor(ms/1000));
    const mm = Math.floor(s/60);
    const ss = s%60;
    return `${pad2(mm)}:${pad2(ss)}`;
  };

  // ---------- BFS (min moves) ----------
  function bfsMinMoves(capacities, goal){
    const n = capacities.length;
    const start = Array(n).fill(0);
    const key = (st) => st.join(',');
    const q = [{st:start, d:0}];
    const seen = new Set([key(start)]);
    const isGoal = (st) => st.some(v => v === goal);
    if (isGoal(start)) return 0;

    while(q.length){
      const {st, d} = q.shift();
      for(let i=0;i<n;i++){
        // fill
        if(st[i] !== capacities[i]){
          const ns = st.slice(); ns[i] = capacities[i];
          const k = key(ns);
          if(!seen.has(k)){
            if(isGoal(ns)) return d+1;
            seen.add(k); q.push({st:ns,d:d+1});
          }
        }
        // empty
        if(st[i] !== 0){
          const ns = st.slice(); ns[i] = 0;
          const k = key(ns);
          if(!seen.has(k)){
            if(isGoal(ns)) return d+1;
            seen.add(k); q.push({st:ns,d:d+1});
          }
        }
        // pour
        if(st[i] !== 0){
          for(let j=0;j<n;j++){
            if(i===j) continue;
            if(st[j] === capacities[j]) continue;
            const amount = Math.min(st[i], capacities[j]-st[j]);
            if(amount<=0) continue;
            const ns = st.slice();
            ns[i] -= amount;
            ns[j] += amount;
            const k = key(ns);
            if(!seen.has(k)){
              if(isGoal(ns)) return d+1;
              seen.add(k); q.push({st:ns,d:d+1});
            }
          }
        }
      }
    }
    return null;
  }

  // ---------- BFS path (for DEV auto-clear) ----------
  function bfsPath(capacities, goal){
    const n = capacities.length;
    const start = Array(n).fill(0);
    const key = (st) => st.join(',');
    const isGoal = (st) => st.some(v => v === goal);

    const q = [start];
    const parent = new Map(); // key -> {prev, st}
    parent.set(key(start), {prev:null, st:start});

    while(q.length){
      const st = q.shift();
      if(isGoal(st)){
        const path = [];
        let k = key(st);
        while(k){
          const node = parent.get(k);
          path.push(node.st);
          k = node.prev;
        }
        path.reverse();
        return path;
      }

      for(let i=0;i<n;i++){
        if(st[i] !== capacities[i]){
          const ns = st.slice(); ns[i] = capacities[i];
          const nk = key(ns);
          if(!parent.has(nk)){ parent.set(nk,{prev:key(st), st:ns}); q.push(ns); }
        }
        if(st[i] !== 0){
          const ns = st.slice(); ns[i] = 0;
          const nk = key(ns);
          if(!parent.has(nk)){ parent.set(nk,{prev:key(st), st:ns}); q.push(ns); }
        }
        if(st[i] !== 0){
          for(let j=0;j<n;j++){
            if(i===j) continue;
            if(st[j] === capacities[j]) continue;
            const amount = Math.min(st[i], capacities[j]-st[j]);
            if(amount<=0) continue;
            const ns = st.slice();
            ns[i]-=amount; ns[j]+=amount;
            const nk = key(ns);
            if(!parent.has(nk)){ parent.set(nk,{prev:key(st), st:ns}); q.push(ns); }
          }
        }
      }
    }
    return null;
  }

  // ---------- Stages (raw) ----------
  const normalStagesRaw = [
    {caps:[3,5], goal:4},
    {caps:[2,7], goal:5},
    {caps:[4,7], goal:3},
    {caps:[5,8], goal:6},
    {caps:[6,10], goal:2},
    {caps:[3,8], goal:7},
    {caps:[4,9], goal:1},
    {caps:[5,9], goal:7},
    {caps:[6,11], goal:5},
    {caps:[7,11], goal:6},
    {caps:[3,5,8], goal:4},
    {caps:[3,7,10], goal:6},
    {caps:[4,7,9], goal:5},
    {caps:[5,8,13], goal:6},
    {caps:[3,6,11], goal:8},
    {caps:[3,7,11], goal:5},
    {caps:[4,9,13], goal:10},
    {caps:[5,7,12], goal:6},
    {caps:[3,8,14], goal:11},
    {caps:[3,7,15], goal:9},
  ];

  const hardStagesRaw = [
    {caps:[3,5], goal:4},
    {caps:[2,9], goal:7},
    {caps:[5,8], goal:6},
    {caps:[4,7], goal:5},
    {caps:[3,7,11], goal:5},
    {caps:[6,11], goal:1},
    {caps:[6,10], goal:5},  // 일부는 가능한데 "불가능" 판단을 유도할 수 있는 것들
    {caps:[4,8], goal:6},
    {caps:[3,9], goal:4},
    {caps:[5,15], goal:4},
  ];

  // ---------- 난이도 정렬 ----------
  function difficultyScore(stage){
    const min = bfsMinMoves(stage.caps, stage.goal);
    const n = stage.caps.length;
    // minMoves가 가장 큰 영향, 3통이면 약간 가산, 목표가 "너무 가까운 값"이면 약간 감점
    const capsSorted = stage.caps.slice().sort((a,b)=>a-b);
    const maxC = capsSorted[capsSorted.length-1];
    const trivial = (stage.goal === 1 || stage.goal === maxC-1) ? -0.4 : 0;
    const nBonus = (n===3) ? 0.6 : 0;
    const minMoves = (min==null) ? 999 : min;

    return (minMoves * 1.0) + nBonus + trivial;
  }

  function buildSortedStages(raw, mode){
    const arr = raw.map(s => {
      const min = bfsMinMoves(s.caps, s.goal);
      return {...s, _min:min, _diff:difficultyScore(s)};
    });

    // Normal은 쉬운→어려운 순, Hard도 쉬운→어려운 순(불가능 포함 여부는 지금 raw에 이미 섞여 있음)
    arr.sort((a,b) => a._diff - b._diff);

    // 정렬 후 _min이 null(불가능)이 있다면 Hard에서는 뒤쪽으로 보내기
    if(mode === "hard"){
      const solv = arr.filter(x => x._min !== null);
      const imp  = arr.filter(x => x._min === null);
      return solv.concat(imp);
    }
    return arr;
  }

  // ---------- Tiers (재설정: 7/7/6) ----------
  const tiers = [
    {name:"초급", from:1, to:7},
    {name:"중급", from:8, to:14},
    {name:"고급", from:15, to:20},
  ];

  const hintLevels = [
    "한 번에 해결하려고 하지 말고, 먼저 ‘중간 상태’를 만들어 보세요.",
    "작은 통을 ‘측정 도구’처럼 써 보세요. 가득 채우고 옮기면 남는 양이 생깁니다.",
    "같은 상태가 반복되면, 다른 선택을 해 보세요."
  ];

  // ---------- State ----------
  const state = {
    mode: null,
    stages: [],
    idx: 0,
    caps: [],
    goal: 0,
    amounts: [],
    selected: null,
    moves: 0,
    startMs: 0,
    timerId: null,
    loopSet: new Set(),
    loopDetected: false,
    minMoves: null,
    hintUsed: 0,
    records: [],
    jugUI: [],
    isAutoSolving: false
  };

  // ---------- DOM ----------
  const startScreen = $("#startScreen");
  const gameScreen = $("#gameScreen");

  const modeTitle = $("#modeTitle");
  const tierBadge = $("#tierBadge");
  const progressBadge = $("#progressBadge");
  const stageDesc = $("#stageDesc");
  const stageNo = $("#stageNo");
  const goalText = $("#goalText");
  const movesText = $("#movesText");
  const timeText = $("#timeText");

  const jugsEl = $("#jugs");
  const selectInfo = $("#selectInfo");
  const loopBanner = $("#loopBanner");
  const btnDeclareImpossible = $("#btnDeclareImpossible");
  const modeStateText = $("#modeStateText");

  const normalHintArea = $("#normalHintArea");
  const hardNoteArea = $("#hardNoteArea");
  const hintBox = $("#hintBox");
  const btnHint = $("#btnHint");
  const jugPanel = $("#jugPanel");

  const modalOverlay = $("#modalOverlay");
  const modalTitle = $("#modalTitle");
  const modalBody = $("#modalBody");
  const modalFooter = $("#modalFooter");

  function el(tag, cls){
    const n = document.createElement(tag);
    if(cls) n.className = cls;
    return n;
  }
  function showModal(title, bodyNode, footerButtons){
    modalTitle.textContent = title;
    modalBody.innerHTML = "";
    modalBody.appendChild(bodyNode);
    modalFooter.innerHTML = "";
    footerButtons.forEach(b => modalFooter.appendChild(b));
    modalOverlay.style.display = "flex";
  }
  function closeModal(){ modalOverlay.style.display = "none"; }
  $("#btnCloseModal").addEventListener("click", closeModal);
  modalOverlay.addEventListener("click", (e) => { if(e.target === modalOverlay) closeModal(); });

  function setScreen(which){
    if(which === "start"){
      startScreen.style.display = "";
      gameScreen.style.display = "none";
      stopTimer();
    }else{
      startScreen.style.display = "none";
      gameScreen.style.display = "";
    }
  }

  // ---------- Timer ----------
  function stopTimer(){
    if(state.timerId){
      clearInterval(state.timerId);
      state.timerId = null;
    }
  }
  function startTimer(){
    stopTimer();
    state.timerId = setInterval(() => {
      const ms = Date.now() - state.startMs;
      timeText.textContent = msToMMSS(ms);
    }, 250);
    timeText.textContent = "00:00";
  }

  // ---------- SVG jug ----------
  function createJugElement(jugIndex, cap){
    const W = 120, H = 210;
    const innerX = 22, innerY = 22, innerW = 76, innerH = 160;

    const tickSideX = innerX + innerW + 6;
    const tick0Y = innerY + innerH;
    const tickMidY = innerY + innerH/2;
    const tickMaxY = innerY;

    const jugCard = el("div","jug");
    jugCard.setAttribute("role","button");
    jugCard.setAttribute("tabindex","0");

    const head = el("div","cap");
    head.innerHTML = `<span>${jugIndex+1}번 통</span><strong>${cap}L</strong>`;

    const svgWrap = el("div","jugSvgWrap");

    const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
    svg.setAttribute("viewBox", `0 0 ${W} ${H}`);
    svg.setAttribute("width","100%");
    svg.setAttribute("height","100%");
    // 바닥 정렬(떠 보임 완화)
    svg.setAttribute("preserveAspectRatio", "xMidYMax meet");

    const defs = document.createElementNS("http://www.w3.org/2000/svg","defs");
    const id = `s${state.idx}_j${jugIndex}_${Math.random().toString(16).slice(2)}`;

    const cupGrad = document.createElementNS("http://www.w3.org/2000/svg","linearGradient");
    cupGrad.setAttribute("id", `cupGrad-${id}`);
    cupGrad.setAttribute("x1","0"); cupGrad.setAttribute("y1","0");
    cupGrad.setAttribute("x2","1"); cupGrad.setAttribute("y2","0");
    cupGrad.innerHTML = `
      <stop offset="0" stop-color="rgba(255,255,255,.08)"/>
      <stop offset="0.35" stop-color="rgba(255,255,255,.03)"/>
      <stop offset="0.7" stop-color="rgba(255,255,255,.07)"/>
      <stop offset="1" stop-color="rgba(255,255,255,.04)"/>
    `;

    const waterGrad = document.createElementNS("http://www.w3.org/2000/svg","linearGradient");
    waterGrad.setAttribute("id", `waterGrad-${id}`);
    waterGrad.setAttribute("x1","0"); waterGrad.setAttribute("y1","0");
    waterGrad.setAttribute("x2","0"); waterGrad.setAttribute("y2","1");
    waterGrad.innerHTML = `
      <stop offset="0" stop-color="var(--waterTop)"/>
      <stop offset="1" stop-color="var(--waterBottom)"/>
    `;

    const clip = document.createElementNS("http://www.w3.org/2000/svg","clipPath");
    clip.setAttribute("id", `cupClip-${id}`);
    const innerRect = document.createElementNS("http://www.w3.org/2000/svg","rect");
    innerRect.setAttribute("x", innerX);
    innerRect.setAttribute("y", innerY);
    innerRect.setAttribute("width", innerW);
    innerRect.setAttribute("height", innerH);
    innerRect.setAttribute("rx","10");
    clip.appendChild(innerRect);

    defs.appendChild(cupGrad);
    defs.appendChild(waterGrad);
    defs.appendChild(clip);
    svg.appendChild(defs);

    const baseShadow = document.createElementNS("http://www.w3.org/2000/svg","ellipse");
    baseShadow.setAttribute("cx", W/2);
    baseShadow.setAttribute("cy", H-10);
    baseShadow.setAttribute("rx","36");
    baseShadow.setAttribute("ry","8");
    baseShadow.setAttribute("fill","rgba(0,0,0,.25)");
    svg.appendChild(baseShadow);

    const cupG = document.createElementNS("http://www.w3.org/2000/svg","g");

    const outer = document.createElementNS("http://www.w3.org/2000/svg","path");
    outer.setAttribute("d",
      "M 18 20 Q 18 10 28 10 L 92 10 Q 102 10 102 20 L 106 184 Q 106 198 92 198 L 28 198 Q 14 198 14 184 Z"
    );
    outer.setAttribute("fill", `url(#cupGrad-${id})`);
    outer.setAttribute("stroke", "var(--cup-stroke)");
    outer.setAttribute("stroke-width","1.2");
    cupG.appendChild(outer);

    const rim = document.createElementNS("http://www.w3.org/2000/svg","path");
    rim.setAttribute("d",
      "M 26 10 L 94 10 Q 102 10 102 18 L 102 22 Q 102 14 94 14 L 26 14 Q 18 14 18 22 L 18 18 Q 18 10 26 10 Z"
    );
    rim.setAttribute("fill","rgba(255,255,255,.10)");
    rim.setAttribute("stroke","rgba(255,255,255,.18)");
    rim.setAttribute("stroke-width",".6");
    cupG.appendChild(rim);

    const base = document.createElementNS("http://www.w3.org/2000/svg","rect");
    base.setAttribute("x","18"); base.setAttribute("y","186");
    base.setAttribute("width","88"); base.setAttribute("height","14");
    base.setAttribute("rx","10");
    base.setAttribute("fill","rgba(255,255,255,.07)");
    base.setAttribute("stroke","rgba(255,255,255,.12)");
    base.setAttribute("stroke-width",".6");
    cupG.appendChild(base);

    const wall = document.createElementNS("http://www.w3.org/2000/svg","rect");
    wall.setAttribute("x", innerX);
    wall.setAttribute("y", innerY);
    wall.setAttribute("width", innerW);
    wall.setAttribute("height", innerH);
    wall.setAttribute("rx","10");
    wall.setAttribute("fill","rgba(0,0,0,.18)");
    wall.setAttribute("stroke","rgba(255,255,255,.10)");
    wall.setAttribute("stroke-width",".6");
    cupG.appendChild(wall);

    const hi = document.createElementNS("http://www.w3.org/2000/svg","rect");
    hi.setAttribute("x","28"); hi.setAttribute("y","22");
    hi.setAttribute("width","10"); hi.setAttribute("height","164");
    hi.setAttribute("rx","6");
    hi.setAttribute("fill","rgba(255,255,255,.07)");
    cupG.appendChild(hi);

    svg.appendChild(cupG);

    const waterClipG = document.createElementNS("http://www.w3.org/2000/svg","g");
    waterClipG.setAttribute("clip-path", `url(#cupClip-${id})`);

    const waterGroup = document.createElementNS("http://www.w3.org/2000/svg","g");
    waterGroup.classList.add("waterGroup");

    const waterRect = document.createElementNS("http://www.w3.org/2000/svg","rect");
    waterRect.setAttribute("x", innerX);
    waterRect.setAttribute("y", innerY);
    waterRect.setAttribute("width", innerW);
    waterRect.setAttribute("height", innerH);
    waterRect.setAttribute("fill", `url(#waterGrad-${id})`);
    waterGroup.appendChild(waterRect);

    const waveGroup = document.createElementNS("http://www.w3.org/2000/svg","g");
    waveGroup.classList.add("waveWiggle");

    const wavePath = document.createElementNS("http://www.w3.org/2000/svg","path");
    wavePath.setAttribute("fill","none");
    wavePath.setAttribute("stroke","var(--waterEdge)");
    wavePath.setAttribute("stroke-width","1");
    wavePath.setAttribute("opacity",".65");
    waveGroup.appendChild(wavePath);

    waterClipG.appendChild(waterGroup);
    waterClipG.appendChild(waveGroup);
    svg.appendChild(waterClipG);

    const tickG = document.createElementNS("http://www.w3.org/2000/svg","g");
    tickG.setAttribute("opacity",".95");

    function tickLine(y, len){
      const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
      ln.setAttribute("x1", tickSideX);
      ln.setAttribute("y1", y);
      ln.setAttribute("x2", tickSideX + len);
      ln.setAttribute("y2", y);
      ln.setAttribute("stroke","var(--tick)");
      ln.setAttribute("stroke-width","1");
      return ln;
    }
    tickG.appendChild(tickLine(tickMaxY, 10));
    tickG.appendChild(tickLine(tickMidY, 8));
    tickG.appendChild(tickLine(tick0Y, 10));

    function tickText(y, text){
      const t = document.createElementNS("http://www.w3.org/2000/svg","text");
      t.setAttribute("x", tickSideX + 12);
      t.setAttribute("y", y + 4);
      t.setAttribute("font-size","10");
      t.setAttribute("fill","var(--tickText)");
      t.textContent = text;
      return t;
    }
    tickG.appendChild(tickText(tickMaxY, String(cap)));
    tickG.appendChild(tickText(tickMidY, String(Math.round(cap/2))));
    tickG.appendChild(tickText(tick0Y, "0"));
    svg.appendChild(tickG);

    svgWrap.appendChild(svg);

    const amt = el("div","amt");
    const amtLeft = el("span"); amtLeft.textContent = "현재";
    const amtStrong = el("strong"); amtStrong.textContent = "0L";
    amt.appendChild(amtLeft);
    amt.appendChild(amtStrong);

    jugCard.appendChild(head);
    jugCard.appendChild(svgWrap);
    jugCard.appendChild(amt);

    jugCard.addEventListener("click", () => {
      if(state.isAutoSolving) return;
      onJugClick(jugIndex);
    });
    jugCard.addEventListener("keydown", (e) => {
      if(state.isAutoSolving) return;
      if(e.key === "Enter" || e.key === " ") { e.preventDefault(); onJugClick(jugIndex); }
    });

    return {
      jugCard,
      svgWrap,
      amtStrong,
      waterGroup,
      wavePath,
      waveGroup,
      geom: { innerX, innerY, innerW, innerH },
    };
  }

  function setWavePath(refs, waterTopY){
    const { innerX, innerW } = refs.geom;
    const amp = 2.2;
    const x0 = innerX, x1 = innerX + innerW;
    const c1 = innerX + innerW*0.25;
    const c2 = innerX + innerW*0.45;
    const c3 = innerX + innerW*0.60;
    const c4 = innerX + innerW*0.75;
    const c5 = innerX + innerW*0.88;

    const d = `M ${x0} ${waterTopY}
      C ${c1} ${waterTopY-amp}, ${c2} ${waterTopY+amp}, ${c3} ${waterTopY}
      C ${c4} ${waterTopY-amp}, ${c5} ${waterTopY+amp}, ${x1} ${waterTopY}`;
    refs.wavePath.setAttribute("d", d);
    refs.waveGroup.setAttribute("transform", `translate(0,0)`);
  }

  function updateWaterVisual(jugIndex){
    const cap = state.caps[jugIndex];
    const amt = state.amounts[jugIndex];
    const refs = state.jugUI[jugIndex];

    refs.amtStrong.textContent = `${amt}L`;

    const { innerY, innerH } = refs.geom;
    const waterH = (amt / cap) * innerH;
    const offset = innerH - waterH;
    refs.waterGroup.style.transform = `translate(0px, ${offset}px)`;

    const waterTopY = innerY + offset;
    setWavePath(refs, waterTopY);
  }

  // ---------- 더 자연스러운 통 크기(높이+폭 약간) ----------
  function applyJugSizing(){
    const caps = state.caps.slice();
    const minC = Math.min(...caps);
    const maxC = Math.max(...caps);

    const baseH = 230;
    const minScale = 0.92;   // 극단 줄임
    const maxScale = 1.18;

    for(let i=0;i<caps.length;i++){
      let t = 0;
      if(maxC !== minC) t = (caps[i] - minC) / (maxC - minC);

      // 곡선 스케일로 완만하게(자연스러움)
      const smooth = Math.sqrt(t);
      const scale = minScale + (maxScale - minScale) * smooth;

      const h = Math.round(baseH * scale);
      state.jugUI[i].svgWrap.style.height = `${h}px`;

      // 폭도 아주 살짝만 반영(너무 튀지 않게)
      const baseW = 150;
      const w = Math.round(baseW * (0.98 + 0.08 * smooth)); // 최대 +8% 정도
      state.jugUI[i].jugCard.style.width = `${w}px`;
    }
  }

  function buildJugUI(){
    state.jugUI = [];
    jugsEl.innerHTML = "";
    state.caps.forEach((cap, i) => {
      const refs = createJugElement(i, cap);
      state.jugUI.push(refs);
      jugsEl.appendChild(refs.jugCard);
    });

    applyJugSizing();

    for(let i=0;i<state.caps.length;i++){
      updateWaterVisual(i);
      state.jugUI[i].jugCard.classList.toggle("selected", state.selected === i);
    }
  }

  function updateSelectionUI(){
    for(let i=0;i<state.jugUI.length;i++){
      state.jugUI[i].jugCard.classList.toggle("selected", state.selected === i);
    }
    selectInfo.textContent = state.selected == null
      ? "선택: 없음"
      : `선택: ${state.selected+1}번 통 (${state.caps[state.selected]}L)`;
    modeStateText.textContent = (state.selected == null) ? "현재: 선택 없음" : "현재: 선택됨";
  }

  function cancelSelection(){
    if(state.selected == null) return;
    state.selected = null;
    updateSelectionUI();
  }

  // ---------- 게임 로직 ----------
  function addMoveAndCheckLoop(){
    state.moves += 1;
    movesText.textContent = String(state.moves);

    const key = state.amounts.join(',');
    if(state.loopSet.has(key)){
      state.loopDetected = true;
    }else{
      state.loopSet.add(key);
    }

    if(state.mode === "hard"){
      loopBanner.style.display = state.loopDetected ? "" : "none";
      // 하드에서는 불가능 버튼을 항상 보이되, 반복 감지되면 더 눌러볼 만하다는 신호로만 사용
    }
  }

  function canPourAmount(from, to){
    const capTo = state.caps[to];
    if(state.amounts[from] <= 0) return 0;
    if(state.amounts[to] >= capTo) return 0;
    return Math.min(state.amounts[from], capTo - state.amounts[to]);
  }

  // ✅ 옮기기 모드 제거: 선택된 통이 있을 때 다른 통을 누르면 “옮기기 시도”
  function onJugClick(i){
    if(state.selected == null){
      state.selected = i;
      updateSelectionUI();
      return;
    }
    if(state.selected === i){
      // 같은 통 다시 누르면 선택 취소(편의)
      cancelSelection();
      return;
    }

    const from = state.selected;
    const to = i;
    const amount = canPourAmount(from, to);

    if(amount > 0){
      state.amounts[from] -= amount;
      state.amounts[to] += amount;
      addMoveAndCheckLoop();

      // 옮긴 뒤 선택 자동 취소(실수 방지)
      state.selected = null;
      updateSelectionUI();

      updateWaterVisual(from);
      updateWaterVisual(to);
      checkWin();
    }else{
      // 옮길 수 없으면 그냥 선택을 바꾼다(사용자 의도 보존)
      state.selected = i;
      updateSelectionUI();
    }
  }

  function fillSelected(){
    if(state.selected == null) return;
    const i = state.selected;
    if(state.amounts[i] === state.caps[i]) return;

    state.amounts[i] = state.caps[i];
    addMoveAndCheckLoop();
    updateWaterVisual(i);
    checkWin();
  }

  function emptySelected(){
    if(state.selected == null) return;
    const i = state.selected;
    if(state.amounts[i] === 0) return;

    state.amounts[i] = 0;
    addMoveAndCheckLoop();
    updateWaterVisual(i);
    checkWin();
  }

  function isGoalReached(){
    return state.amounts.some(v => v === state.goal);
  }

  // ✅ 점수식 단순화: 최소 이동이면 무조건 100점
  function computeNormalScore(moves, ms, minMoves){
    if(minMoves == null) return 0;
    if(moves <= minMoves) return 100;

    const diff = moves - minMoves;
    // 이동이 핵심이 되도록 크게 깎기
    let score = 100 - diff * 8;

    // 시간은 아주 약하게만(너무 오래 걸리면 약간)
    const softLimit = (minMoves * 22) * 1000;
    if(ms > softLimit){
      const over = ms - softLimit;
      score -= Math.floor(over / (45*1000)) * 2;
    }
    return Math.max(0, Math.min(100, score));
  }

  // ---------- 화면 상단 단계 표시 ----------
  function getTierNameByStageNumber(stageNumber){
    const t = tiers.find(x => stageNumber >= x.from && stageNumber <= x.to);
    return t ? t.name : "";
  }

  function renderTopUI(){
    modeTitle.textContent = state.mode === "normal" ? "Normal" : "Hard";

    const stageNumber = state.idx + 1;
    stageNo.textContent = String(stageNumber);
    goalText.textContent = `${state.goal}L`;
    movesText.textContent = String(state.moves);

    tierBadge.textContent = getTierNameByStageNumber(stageNumber) || (state.mode === "hard" ? "Hard" : "");
    progressBadge.textContent = `${stageNumber} / ${state.stages.length}`;

    selectInfo.textContent = state.selected == null
      ? "선택: 없음"
      : `선택: ${state.selected+1}번 통 (${state.caps[state.selected]}L)`;
  }

  function renderModeSections(){
    if(state.mode === "normal"){
      stageDesc.textContent = "목표한 물의 양을 만들어 보세요. 이동을 줄이면 점수가 올라갑니다.";
      normalHintArea.style.display = "";
      hardNoteArea.style.display = "none";
      btnDeclareImpossible.style.display = "none";
    }else{
      stageDesc.textContent = "가능/불가능을 판단해야 할 수도 있습니다. 불가능을 눌렀는데 틀리면 1로 돌아갑니다.";
      normalHintArea.style.display = "none";
      hardNoteArea.style.display = "";
      btnDeclareImpossible.style.display = "";
    }
  }

  // ---------- Stage state ----------
  function resetStageState(){
    state.amounts = Array(state.caps.length).fill(0);
    state.selected = null;
    state.moves = 0;
    state.hintUsed = 0;
    state.loopSet = new Set();
    state.loopDetected = false;
    loopBanner.style.display = "none";
    state.loopSet.add(state.amounts.join(','));

    hintBox.textContent = "힌트가 여기에 표시됩니다.";
    btnHint.disabled = false;

    state.startMs = Date.now();
    startTimer();

    buildJugUI();
    updateSelectionUI();
    renderTopUI();
    renderModeSections();
  }

  // ---------- Results / Flow ----------
  function endStage({type}){
    stopTimer();
    const elapsed = Date.now() - state.startMs;

    const record = {
      mode: state.mode,
      stageIndex: state.idx,
      caps: state.caps.slice(),
      goal: state.goal,
      moves: state.moves,
      timeMs: elapsed,
      timeText: msToMMSS(elapsed),
      resultType: type
    };

    if(state.mode === "normal"){
      const min = state.minMoves ?? bfsMinMoves(state.caps, state.goal);
      record.minMoves = min;
      record.score = computeNormalScore(state.moves, elapsed, min);
    }

    state.records.push(record);

    if(state.mode === "normal") showNormalStageClear(record);
    else showHardStageClear(record);
  }

  function showNormalStageClear(rec){
    const body = el("div");
    const grid = el("div","kpiGrid");

    const bScore = el("div","kpiBox big");
    bScore.innerHTML = `<div class="label">점수</div><div class="val">${rec.score} / 100</div>`;

    const bMoves = el("div","kpiBox");
    bMoves.innerHTML = `<div class="label">이동</div><div class="val">${rec.moves}회</div>`;

    const bTime = el("div","kpiBox");
    bTime.innerHTML = `<div class="label">시간</div><div class="val">${rec.timeText}</div>`;

    grid.append(bScore,bMoves,bTime);
    body.appendChild(grid);

    const p = el("p");
    p.textContent = (rec.moves <= rec.minMoves) ? "최소 이동으로 해결했습니다." : "다음에는 이동을 더 줄여보세요.";
    body.appendChild(p);

    const btnNext = el("button","good");
    btnNext.textContent = "다음";
    btnNext.addEventListener("click", () => { closeModal(); goNextNormalOrTier(); });

    showModal("스테이지 클리어", body, [btnNext]);
  }

  function showHardStageClear(rec){
    const body = el("div");
    const grid = el("div","kpiGrid");

    const bRes = el("div","kpiBox big");
    bRes.innerHTML = `<div class="label">결과</div><div class="val">${rec.resultType === "declare-impossible" ? "불가능 정답" : "목표 달성"}</div>`;

    const bMoves = el("div","kpiBox");
    bMoves.innerHTML = `<div class="label">이동</div><div class="val">${rec.moves}회</div>`;

    const bTime = el("div","kpiBox");
    bTime.innerHTML = `<div class="label">시간</div><div class="val">${rec.timeText}</div>`;

    grid.append(bRes,bMoves,bTime);
    body.appendChild(grid);

    const btnNext = el("button","good");
    btnNext.textContent = (state.idx === state.stages.length - 1) ? "결과 보기" : "다음";
    btnNext.addEventListener("click", () => { closeModal(); goNextHardOrEnd(); });

    showModal("완료", body, [btnNext]);
  }

  function goNextNormalOrTier(){
    const stageNumber = state.idx + 1;
    const t = tiers.find(x => x.to === stageNumber);
    if(t){ showTierSummary(t); return; }
    if(state.idx < state.stages.length - 1){
      state.idx += 1;
      loadStage();
    }else{
      showFinalNormalSummary();
    }
  }

  // ✅ 팝업이 뜬금없지 않게: 제목/설명 강화 + 항상 "초/중/고"가 상단에 표시됨
  function showTierSummary(tier){
    const fromIdx = tier.from - 1;
    const toIdx = tier.to - 1;
    const rows = state.records.filter(r => r.mode === "normal" && r.stageIndex >= fromIdx && r.stageIndex <= toIdx);
    const avg = Math.round(rows.reduce((a,b)=>a+(b.score??0),0) / rows.length);

    const body = el("div");
    const p = el("p");
    p.textContent = `${tier.name} 완료 (${tier.from}~${tier.to} 스테이지). 기록을 확인해 보세요.`;
    body.appendChild(p);

    const table = el("table");
    table.innerHTML = `
      <thead>
        <tr><th>스테이지</th><th>이동</th><th>시간</th><th>점수</th></tr>
      </thead>
      <tbody>
        ${rows.map(r => `
          <tr>
            <td>${r.stageIndex+1}</td>
            <td>${r.moves}회</td>
            <td>${r.timeText}</td>
            <td>${r.score} / 100</td>
          </tr>
        `).join('')}
      </tbody>
    `;
    body.appendChild(table);

    const grid = el("div","kpiGrid");
    const b1 = el("div","kpiBox big"); b1.innerHTML = `<div class="label">${tier.name} 평균 점수</div><div class="val">${avg} / 100</div>`;
    const b2 = el("div","kpiBox"); b2.innerHTML = `<div class="label">${tier.name} 총 이동</div><div class="val">${rows.reduce((a,b)=>a+b.moves,0)}회</div>`;
    const b3 = el("div","kpiBox"); b3.innerHTML = `<div class="label">${tier.name} 총 시간</div><div class="val">${msToMMSS(rows.reduce((a,b)=>a+b.timeMs,0))}</div>`;
    grid.append(b1,b2,b3);
    body.insertBefore(grid, table);

    const btnNext = el("button","good");
    btnNext.textContent = (tier.to === 20) ? "최종 결과" : "다음 단계";
    btnNext.addEventListener("click", () => {
      closeModal();
      if(tier.to === 20) showFinalNormalSummary();
      else { state.idx += 1; loadStage(); }
    });

    showModal(`${tier.name} 기록`, body, [btnNext]);
  }

  function showFinalNormalSummary(){
    const rows = state.records.filter(r => r.mode === "normal");
    const tierScores = tiers.map(t => {
      const subset = rows.filter(r => (r.stageIndex+1) >= t.from && (r.stageIndex+1) <= t.to);
      const avg = Math.round(subset.reduce((a,b)=>a+(b.score??0),0)/subset.length);
      return {name:t.name, avg, subset};
    });
    const overall = Math.round(tierScores.reduce((a,b)=>a+b.avg,0)/tierScores.length);

    const body = el("div");
    const grid = el("div","kpiGrid");
    const b1 = el("div","kpiBox big"); b1.innerHTML = `<div class="label">최종 점수</div><div class="val">${overall} / 100</div>`;
    const b2 = el("div","kpiBox"); b2.innerHTML = `<div class="label">총 이동</div><div class="val">${rows.reduce((a,b)=>a+b.moves,0)}회</div>`;
    const b3 = el("div","kpiBox"); b3.innerHTML = `<div class="label">총 시간</div><div class="val">${msToMMSS(rows.reduce((a,b)=>a+b.timeMs,0))}</div>`;
    grid.append(b1,b2,b3);
    body.appendChild(grid);

    const table = el("table");
    table.innerHTML = `
      <thead><tr><th>단계</th><th>평균 점수</th><th>구간</th></tr></thead>
      <tbody>
        ${tierScores.map(t => `
          <tr>
            <td>${t.name}</td>
            <td>${t.avg} / 100</td>
            <td>${t.subset[0].stageIndex+1}–${t.subset[t.subset.length-1].stageIndex+1}</td>
          </tr>
        `).join('')}
      </tbody>
    `;
    body.appendChild(table);

    const btnMenu = el("button","ghost");
    btnMenu.textContent = "메뉴로";
    btnMenu.addEventListener("click", () => { closeModal(); resetToMenu(); });

    showModal("Normal 최종 결과", body, [btnMenu]);
  }

  function goNextHardOrEnd(){
    if(state.idx < state.stages.length - 1){
      state.idx += 1;
      loadStage();
    }else{
      showHardEndSummary();
    }
  }

  function showHardEndSummary(){
    const rows = state.records.filter(r => r.mode === "hard");
    const solved = rows.filter(r => r.resultType === "solve").length;
    const imp = rows.filter(r => r.resultType === "declare-impossible").length;

    const body = el("div");
    const p = el("p");
    p.textContent = `목표 달성: ${solved} / 불가능 정답: ${imp}`;
    body.appendChild(p);

    const btnMenu = el("button","ghost");
    btnMenu.textContent = "메뉴로";
    btnMenu.addEventListener("click", () => { closeModal(); resetToMenu(); });

    showModal("Hard 결과", body, [btnMenu]);
  }

  // ---------- Hard: 불가능 버튼(이유 없음 + 오판 시 1스테이지로) ----------
  function hardDeclareImpossible(){
    // 실제로 가능한지 즉시 판정
    const min = bfsMinMoves(state.caps, state.goal);
    const actuallyImpossible = (min === null);

    if(actuallyImpossible){
      endStage({type:"declare-impossible"});
      return;
    }

    // 오판 패널티: 1스테이지로
    stopTimer();

    const body = el("div");
    const p = el("p");
    p.textContent = "이 스테이지는 해결할 수 있는 문제였습니다. Hard 패널티로 1스테이지로 돌아갑니다.";
    body.appendChild(p);

    const btn = el("button","bad");
    btn.textContent = "1스테이지로";
    btn.addEventListener("click", () => {
      closeModal();
      state.idx = 0;
      loadStage();
    });

    showModal("오판", body, [btn]);
  }

  // ---------- Win ----------
  function checkWin(){
    if(!isGoalReached()) return;
    endStage({type:"solve"});
  }

  // ---------- Stage loading ----------
  function loadStage(){
    const st = state.stages[state.idx];
    state.caps = st.caps.slice();
    state.goal = st.goal;

    state.minMoves = (state.mode === "normal") ? bfsMinMoves(state.caps, state.goal) : null;
    resetStageState();
  }

  function resetToMenu(){
    state.mode = null;
    state.stages = [];
    state.idx = 0;
    state.records = [];
    setScreen("start");
  }

  // ---------- 배경 클릭으로 선택 취소 ----------
  jugPanel.addEventListener("click", (e) => {
    if(state.isAutoSolving) return;
    if(e.target.closest(".jug")) return;
    if(e.target.closest("button")) return;
    cancelSelection();
  });

  // ---------- DEV HOTKEYS (설명 문구는 UI에서 제거됨) ----------
  const DEV_KEYS = new Set(["₩","`","~","\\"]);
  let devHeld = false;

  function isDevKeyEvent(e){
    if(e.code === "Backquote") return true;
    return DEV_KEYS.has(e.key);
  }

  function devMoveStage(delta){
    if(gameScreen.style.display === "none") return;
    if(state.isAutoSolving) return;
    const next = Math.max(0, Math.min(state.stages.length - 1, state.idx + delta));
    if(next === state.idx) return;
    state.idx = next;
    loadStage();
  }

  function devForceClear(){
    if(gameScreen.style.display === "none") return;
    if(state.isAutoSolving) return;

    const path = bfsPath(state.caps, state.goal);
    if(!path){
      // 불가능이면 아무 것도 안 함(개발자만 쓰는 기능이므로 조용히)
      return;
    }

    state.isAutoSolving = true;
    cancelSelection();

    let step = 0;
    const interval = 420;

    const tick = () => {
      if(step >= path.length){
        state.isAutoSolving = false;
        state.moves = (path.length - 1);
        movesText.textContent = String(state.moves);
        endStage({type:"solve"});
        return;
      }
      state.amounts = path[step].slice();
      for(let i=0;i<state.caps.length;i++) updateWaterVisual(i);
      step += 1;
      setTimeout(tick, interval);
    };
    tick();
  }

  document.addEventListener("keydown", (e) => {
    if(modalOverlay.style.display === "flex") return;

    if(isDevKeyEvent(e)){
      devHeld = true;
      return;
    }
    if(!devHeld) return;

    if(e.key === "ArrowLeft"){
      e.preventDefault();
      devMoveStage(-1);
    }else if(e.key === "ArrowRight"){
      e.preventDefault();
      devMoveStage(+1);
    }else if(e.key === "Enter"){
      e.preventDefault();
      devForceClear();
    }
  });

  document.addEventListener("keyup", (e) => {
    if(isDevKeyEvent(e)) devHeld = false;
  });

  // ---------- Events ----------
  $("#btnStartNormal").addEventListener("click", () => {
    state.mode = "normal";
    state.stages = buildSortedStages(normalStagesRaw, "normal"); // ✅ 난이도 자동 정렬
    state.idx = 0;
    state.records = [];
    setScreen("game");
    loadStage();
  });

  $("#btnStartHard").addEventListener("click", () => {
    state.mode = "hard";
    state.stages = buildSortedStages(hardStagesRaw, "hard"); // ✅ 난이도 자동 정렬
    state.idx = 0;
    state.records = [];
    setScreen("game");
    loadStage();
  });

  $("#btnBackToMenu").addEventListener("click", () => {
    const body = el("div");
    const p = el("p");
    p.textContent = "메뉴로 돌아가면 현재 진행 중인 기록은 종료됩니다.";
    body.appendChild(p);

    const btnYes = el("button","bad");
    btnYes.textContent = "메뉴로";
    btnYes.addEventListener("click", () => { closeModal(); resetToMenu(); });

    const btnNo = el("button","good");
    btnNo.textContent = "계속하기";
    btnNo.addEventListener("click", () => closeModal());

    showModal("확인", body, [btnNo, btnYes]);
  });

  $("#btnReset").addEventListener("click", () => {
    const body = el("div");
    const p = el("p");
    p.textContent = "이 스테이지를 처음부터 다시 시작할까요?";
    body.appendChild(p);

    const btnYes = el("button","warn");
    btnYes.textContent = "리셋";
    btnYes.addEventListener("click", () => { closeModal(); resetStageState(); });

    const btnNo = el("button","ghost");
    btnNo.textContent = "취소";
    btnNo.addEventListener("click", () => closeModal());

    showModal("스테이지 리셋", body, [btnNo, btnYes]);
  });

  $("#btnFill").addEventListener("click", () => { if(!state.isAutoSolving){ fillSelected(); renderTopUI(); }});
  $("#btnEmpty").addEventListener("click", () => { if(!state.isAutoSolving){ emptySelected(); renderTopUI(); }});

  btnHint.addEventListener("click", () => {
    state.hintUsed += 1;
    const idx = Math.min(hintLevels.length, state.hintUsed) - 1;
    hintBox.textContent = hintLevels[idx] || hintLevels[hintLevels.length-1];
    if(state.hintUsed >= hintLevels.length) btnHint.disabled = true;
  });

  btnDeclareImpossible.addEventListener("click", () => {
    if(state.mode !== "hard") return;
    if(state.isAutoSolving) return;
    hardDeclareImpossible();
  });

  // initial
  setScreen("start");
})();
</script>
</body>
</html>
